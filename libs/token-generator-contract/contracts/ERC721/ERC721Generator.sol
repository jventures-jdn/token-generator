// contracts/ERC721/ERC721Generator.sol
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.17;

import '@openzeppelin/contracts/token/ERC721/ERC721.sol';
import '@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol';
import '@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol';
import '@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/utils/Counters.sol';
import './ERC721Libs.sol';

contract ERC721Generator is ERC721, ERC721URIStorage, Pausable, Ownable, ERC721Burnable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIdTracker;

    string private _baseTokenURI;

    bool public immutable burnable;
    bool public immutable pausable;
    bool public immutable baseTokenURIChangeable;
    bool public immutable autoId;

    constructor(ERC721Libs.Args memory args_) ERC721(args_.name, args_.symbol) ERC721URIStorage() {
        burnable = args_.burnable;
        pausable = args_.pausable;
        baseTokenURIChangeable = args_.baseTokenURIChangeable;
        autoId = args_.autoId;
        _baseTokenURI = args_.baseTokenURI;
    }

    /* -------------------------------------------------------------------------- */
    /*                                  Modifier                                  */
    /* -------------------------------------------------------------------------- */

    /**
     * @dev Modifier to make a function callable only when the burnable is enabled.
     */
    modifier whenBurnable() {
        require(burnable, 'ERC721Generator: burn functionality not enabled');
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the pausable is enabled.
     */
    modifier whenPausable() {
        require(pausable, 'ERC721Generator: pause functionality not enabled');
        _;
    }

    /**
     * @dev Modifier to make a function callable only when the baseTokenURIChangeable is enabled.
     */
    modifier whenBaseTokenURIChangeable() {
        require(baseTokenURIChangeable, 'ERC721Generator: baseTokenURI functionality not enabled');
        _;
    }

    /* -------------------------------------------------------------------------- */
    /*                                   Method                                   */
    /* -------------------------------------------------------------------------- */

    /* ------------------------------ BaseTokenURI ------------------------------ */

    /**
     * @dev return _baseTokenURI
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev Set new _baseTokenURI
     *
     * Requirements:
     *
     * - the caller must be `owner`
     * - the contract must enabled `tokenURIChangeable`
     */
    function setBaseTokenURI(
        string memory baseTokenURI
    ) public virtual onlyOwner whenBaseTokenURIChangeable {
        _baseTokenURI = baseTokenURI;
    }

    /* ------------------------------- URIStorage ------------------------------- */
    /* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721URIStorage.sol */

    /**
     * @dev See {ERC721-_burn}. This override additionally checks to see if a
     * token-specific URI was set for the token, and if so, it deletes the token URI from
     * the storage mapping.
     */
    function _burn(uint256 tokenId) internal virtual override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
    }

    /**
     * @dev See {ERC721-tokenURI}.
     */
    function tokenURI(
        uint256 tokenId
    ) public view virtual override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }

    /* -------------------------------- Mintable -------------------------------- */

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_safeMint}.
     *
     * Requirements:
     * - The caller must be owner
     * - `autoId` need to be enabled when construct.
     * - `_baseTokenURI` need to be set when construct.
     */
    function mint(address to) public virtual onlyOwner {
        require(
            autoId == true,
            'ERC721Generator: `autoId` functionality need to be enabled, consider using `mintTokenId()` or `mintTokenIdUri()` instead.'
        );
        require(
            bytes(_baseTokenURI).length != 0,
            'ERC721Generator: `_baseTokenURI` need to be set, consider using `mintUri()` or `mintTokenIdUri()` instead.'
        );

        _safeMint(to, _tokenIdTracker.current());
        _tokenIdTracker.increment();
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be manully
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_safeMint}.
     *
     * Requirements:
     * - The caller must be owner
     * - `autoId` must not be enabled when construct.
     * - `_baseTokenURI` need to be set when construct.
     */
    function mintTokenId(address to, uint256 tokenId) public virtual onlyOwner {
        require(
            autoId != true,
            'ERC721Generator: `autoId` functionality must not be enabled, consider using `mint()` or `mintUri()` instead.'
        );
        require(
            bytes(_baseTokenURI).length != 0,
            'ERC721Generator: `_baseTokenURI` need to be set, consider using `mintUri()` or `mintTokenIdUri()` instead.'
        );

        _safeMint(to, tokenId);
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI manually storage from parameter.
     *
     * See {ERC721-_safeMint}.
     *
     * Requirements:
     * - The caller must be owner
     * - `autoId` need to be enabled when construct.
     * - `_baseTokenURI` must not be set when construct.
     */
    function mintUri(address to, string memory uri) public virtual onlyOwner {
        require(
            autoId == true,
            'ERC721Generator: `autoId` functionality need to enabled, consider using `mintTokenId()` or `mintTokenIdUri()`'
        );
        require(
            bytes(_baseTokenURI).length == 0,
            'ERC721Generator: `_baseTokenURI` must not be set, consider using `mint()` or `mintTokenId()` instead.'
        );

        _safeMint(to, _tokenIdTracker.current());
        _setTokenURI(_tokenIdTracker.current(), uri);
        _tokenIdTracker.increment();
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be manully
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI manually storage from parameter.
     *
     * See {ERC721-_safeMint}.
     *
     * Requirements:
     * - The caller must be owner
     * - `autoId` must not be enabled when construct.
     * - `_baseTokenURI` must not be set when construct.
     */
    function mintTokenIdUri(
        address to,
        uint256 tokenId,
        string memory uri
    ) public virtual onlyOwner {
        require(
            autoId != true,
            'ERC721Generator: `autoId` functionality must not be enabled, consider using `mint()` or `mintUri()` instead.'
        );
        require(
            bytes(_baseTokenURI).length == 0,
            'ERC721Generator: `_baseTokenURI` must not be set, consider using `mint()` or `mintTokenId()` instead.'
        );

        _safeMint(to, tokenId);
        _setTokenURI(tokenId, uri);
    }

    /* -------------------------------- Burnable -------------------------------- */
    /* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Burnable.sol */

    /**
     * @dev Burns `tokenId`. See {ERC721-_burn}.
     *
     * Requirements:
     *
     * - The caller must own `tokenId` or be an approved operator.
     * - the contract must enabled burnable
     */
    function burn(uint256 tokenId) public virtual override whenBurnable {
        //solhint-disable-next-line max-line-length
        require(
            _isApprovedOrOwner(_msgSender(), tokenId),
            'ERC721: caller is not token owner or approved'
        );
        _burn(tokenId);
    }

    /* -------------------------------- Pausable -------------------------------- */
    /* https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/extensions/ERC721Pausable.sol */

    /**
     * @dev See {ERC721-_beforeTokenTransfer}.
     *
     * Requirements:
     *
     * - the contract must not be paused.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId,
        uint256 batchSize
    ) internal virtual override(ERC721) whenNotPaused {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
    }

    /**
     * @dev Pauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_pause}.
     *
     * Requirements:
     *
     * - The contract must enabled `pausable`.
     * - the caller must be `owner`.
     */
    function pause() public virtual onlyOwner whenPausable {
        _pause();
    }

    /**
     * @dev Unpauses all token transfers.
     *
     * See {ERC721Pausable} and {Pausable-_unpause}.
     *
     * Requirements:
     *
     * - The contract must enabled `pausable`.
     * - the caller must be `owner`.
     */
    function unpause() public virtual onlyOwner whenPausable {
        _unpause();
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(
        bytes4 interfaceId
    ) public view virtual override(ERC721, ERC721URIStorage) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
